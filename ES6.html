<!doctype html>
<html>
<head><meta charset="utf-8"><style>#right-panel {
    background-color: #fff;
}

#right-panel .cover-top {
    background: linear-gradient(to bottom, #fff 50%, transparent);
}

#cover-bottom #cover-bottom-background-right {
    background: #fff;
}

@font-face {
  font-family: octicons-link;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format('woff');
}

#container {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #373737;
  font-family: "Roboto", "Noto Sans", "Ubuntu", "Helvetica Neue", Helvetica, "Segoe UI", Arial, sans-serif, "Noto Sans CJK SC", "Source Han Sans SC", "Microsoft Yahei";
  font-size: 14px;
  line-height: 2;
  word-wrap: break-word;
  background-color: #fff;
}

#container a {
  background-color: transparent;
  -webkit-text-decoration-skip: objects;
}

#container a:active,
#container a:hover {
  outline-width: 0;
}

#container strong {
  font-weight: inherit;
}

#container strong {
  font-weight: bolder;
}

#container h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

#container img {
  border-style: none;
}

#container svg:not(:root) {
  overflow: hidden;
}

#container code,
#container kbd,
#container pre {
  font-family: "Roboto Mono", "Ubuntu Mono", "Menlo", "Consolas", monospace;
  font-size: 1em;
}

#container hr {
  box-sizing: content-box;
  height: 0;
  overflow: visible;
}

#container input {
  font: inherit;
  margin: 0;
}

#container input {
  overflow: visible;
}

#container button:-moz-focusring,
#container [type="button"]:-moz-focusring,
#container [type="reset"]:-moz-focusring,
#container [type="submit"]:-moz-focusring {
  outline: 1px dotted ButtonText;
}

#container [type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

#container table {
  border-spacing: 0;
  border-collapse: collapse;
}

#container td,
#container th {
  padding: 0;
}

#container * {
  box-sizing: border-box;
}

#container input {
  font: 13px/1.4 Helvetica, arial, nimbussansl, liberationsans, freesans, clean, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
}

#container a {
  color: #4078c0;
  text-decoration: none;
}

#container a:hover,
#container a:active {
  text-decoration: underline;
}

#container hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

#container hr::before {
  display: table;
  content: "";
}

#container hr::after {
  display: table;
  clear: both;
  content: "";
}

#container h1,
#container h2,
#container h3,
#container h4,
#container h5,
#container h6 {
  margin-top: 0;
  margin-bottom: 0;
  line-height: 1.5;
}

#container h1 {
  font-size: 30px;
}

#container h2 {
  font-size: 21px;
}

#container h3 {
  font-size: 16px;
}

#container h4 {
  font-size: 14px;
}

#container h5 {
  font-size: 12px;
}

#container h6 {
  font-size: 11px;
}

#container p {
  margin-top: 0;
  margin-bottom: 10px;
}

#container blockquote {
  margin: 0;
}

#container ul,
#container ol {
  padding-left: 0;
  margin-top: 0;
  margin-bottom: 0;
}

#container ol ol,
#container ul ol {
  list-style-type: lower-roman;
}

#container ul ul ol,
#container ul ol ol,
#container ol ul ol,
#container ol ol ol {
  list-style-type: lower-alpha;
}

#container dd {
  margin-left: 0;
}

#container code {
  font-family: "Roboto Mono", "Ubuntu Mono", "Menlo", "Consolas", monospace;
  font-size: 12px;
}

#container pre {
  margin-top: 0;
  margin-bottom: 0;
  font: 12px "Roboto Mono", "Ubuntu Mono", "Menlo", "Consolas", monospace;
}

#container .pl-0 {
  padding-left: 0 !important;
}

#container .pl-1 {
  padding-left: 3px !important;
}

#container .pl-2 {
  padding-left: 6px !important;
}

#container .pl-3 {
  padding-left: 12px !important;
}

#container .pl-4 {
  padding-left: 24px !important;
}

#container .pl-5 {
  padding-left: 36px !important;
}

#container .pl-6 {
  padding-left: 48px !important;
}

#container .form-select::-ms-expand {
  opacity: 0;
}

#container:before {
  display: table;
  content: "";
}

#container:after {
  display: table;
  clear: both;
  content: "";
}

#container>*:first-child {
  margin-top: 0 !important;
}

#container>*:last-child {
  margin-bottom: 0 !important;
}

#container a:not([href]) {
  color: inherit;
  text-decoration: none;
}

#container .anchor {
  display: inline-block;
  padding-right: 2px;
  margin-left: -18px;
}

#container .anchor:focus {
  outline: none;
}

#container h1,
#container h2,
#container h3,
#container h4,
#container h5,
#container h6 {
  margin-top: 1em;
  margin-bottom: 16px;
  font-weight: bold;
  line-height: 1.4;
}

#container h1 .octicon-link,
#container h2 .octicon-link,
#container h3 .octicon-link,
#container h4 .octicon-link,
#container h5 .octicon-link,
#container h6 .octicon-link {
  color: #000;
  vertical-align: middle;
  visibility: hidden;
}

#container h1:hover .anchor,
#container h2:hover .anchor,
#container h3:hover .anchor,
#container h4:hover .anchor,
#container h5:hover .anchor,
#container h6:hover .anchor {
  text-decoration: none;
}

#container h1:hover .anchor .octicon-link,
#container h2:hover .anchor .octicon-link,
#container h3:hover .anchor .octicon-link,
#container h4:hover .anchor .octicon-link,
#container h5:hover .anchor .octicon-link,
#container h6:hover .anchor .octicon-link {
  visibility: visible;
}

#container h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

#container h1 .anchor {
  line-height: 1;
}

#container h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

#container h2 .anchor {
  line-height: 1;
}

#container h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

#container h3 .anchor {
  line-height: 1.2;
}

#container h4 {
  font-size: 1.25em;
}

#container h4 .anchor {
  line-height: 1.2;
}

#container h5 {
  font-size: 1em;
}

#container h5 .anchor {
  line-height: 1.1;
}

#container h6 {
  font-size: 1em;
  color: #777;
}

#container h6 .anchor {
  line-height: 1.1;
}

#container p,
#container blockquote,
#container ul,
#container ol,
#container dl,
#container table,
#container pre {
  margin-top: 0;
  margin-bottom: 16px;
}

#container hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

#container ul,
#container ol {
  padding-left: 2em;
}

#container ul ul,
#container ul ol,
#container ol ol,
#container ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

#container li>p {
  margin-top: 16px;
}

#container dl {
  padding: 0;
}

#container dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

#container dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

#container blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

#container blockquote>:first-child {
  margin-top: 0;
}

#container blockquote>:last-child {
  margin-bottom: 0;
}

#container table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

#container table th {
  font-weight: bold;
}

#container table th,
#container table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

#container table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

#container table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

#container img {
  max-width: 100%;
  box-sizing: content-box;
  background-color: #fff;
}

#container code {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

#container code:before,
#container code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

#container pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

#container .highlight {
  margin-bottom: 16px;
}

#container .highlight pre,
#container pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

#container .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

#container pre {
  word-wrap: normal;
}

#container pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

#container pre code:before,
#container pre code:after {
  content: normal;
}

#container kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb;
}

#container .pl-c {
  color: #969896;
}

#container .pl-c1,
#container .pl-s .pl-v {
  color: #0086b3;
}

#container .pl-e,
#container .pl-en {
  color: #795da3;
}

#container .pl-s .pl-s1,
#container .pl-smi {
  color: #333;
}

#container .pl-ent {
  color: #63a35c;
}

#container .pl-k {
  color: #a71d5d;
}

#container .pl-pds,
#container .pl-s,
#container .pl-s .pl-pse .pl-s1,
#container .pl-sr,
#container .pl-sr .pl-cce,
#container .pl-sr .pl-sra,
#container .pl-sr .pl-sre {
  color: #183691;
}

#container .pl-v {
  color: #ed6a43;
}

#container .pl-id {
  color: #b52a1d;
}

#container .pl-ii {
  background-color: #b52a1d;
  color: #f8f8f8;
}

#container .pl-sr .pl-cce {
  color: #63a35c;
  font-weight: bold;
}

#container .pl-ml {
  color: #693a17;
}

#container .pl-mh,
#container .pl-mh .pl-en,
#container .pl-ms {
  color: #1d3e81;
  font-weight: bold;
}

#container .pl-mq {
  color: #008080;
}

#container .pl-mi {
  color: #333;
  font-style: italic;
}

#container .pl-mb {
  color: #333;
  font-weight: bold;
}

#container .pl-md {
  background-color: #ffecec;
  color: #bd2c00;
}

#container .pl-mi1 {
  background-color: #eaffea;
  color: #55a532;
}

#container .pl-mdr {
  color: #795da3;
  font-weight: bold;
}

#container .pl-mo {
  color: #1d3e81;
}

#container kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px "Roboto Mono", "Ubuntu Mono", "Menlo", "Consolas", monospace;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb;
}

#container .full-commit .btn-outline:not(:disabled):hover {
  color: #4078c0;
  border: 1px solid #4078c0;
}

#container :checked+.radio-label {
  position: relative;
  z-index: 1;
  border-color: #4078c0;
}

#container .octicon {
  display: inline-block;
  vertical-align: text-top;
  fill: currentColor;
}

#container .task-list-item {
  list-style-type: none;
}

#container .task-list-item+.task-list-item {
  margin-top: 3px;
}

#container .task-list-item input {
  margin: 0 0.2em 0.25em -1.6em;
  vertical-align: middle;
}

#container hr {
  border-bottom-color: #eee;
}
</style><style>/*

github.com style (c) Vasily Polovnyov <vast@whiteants.net>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #333;
  background: #f8f8f8;
}

.hljs-comment,
.hljs-quote {
  color: #998;
  font-style: italic;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-subst {
  color: #333;
  font-weight: bold;
}

.hljs-number,
.hljs-literal,
.hljs-variable,
.hljs-template-variable,
.hljs-tag .hljs-attr {
  color: #008080;
}

.hljs-string,
.hljs-doctag {
  color: #d14;
}

.hljs-title,
.hljs-section,
.hljs-selector-id {
  color: #900;
  font-weight: bold;
}

.hljs-subst {
  font-weight: normal;
}

.hljs-type,
.hljs-class .hljs-title {
  color: #458;
  font-weight: bold;
}

.hljs-tag,
.hljs-name,
.hljs-attribute {
  color: #000080;
  font-weight: normal;
}

.hljs-regexp,
.hljs-link {
  color: #009926;
}

.hljs-symbol,
.hljs-bullet {
  color: #990073;
}

.hljs-built_in,
.hljs-builtin-name {
  color: #0086b3;
}

.hljs-meta {
  color: #999;
  font-weight: bold;
}

.hljs-deletion {
  background: #fdd;
}

.hljs-addition {
  background: #dfd;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}
</style></head><body id="container" class="export export-html"><span i="1"><h1 id="1-let-const">1. let和const</h1>
</span><span i="2"><h2 id="-let">① let</h2>
</span><span i="3"><p>let声明的变量只在let所在代码块内有效<br>let只能声明变量一次，var可以重复声明<br>在for循环中，let声明的变量只在当前轮循环有效，循环时如果使用let定义的变量，则每次循环时都相当于使用了不同的变量：<br><em>例：</em>        </p>
</span><span i="8"><pre><code><span class="hljs-meta">'use strict'</span>

<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)
{
    setTimeout(
        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)
        </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'i = '</span> + i);
        }
        )
}

<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)
{
    setTimeout(
        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)
        </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'j = '</span> + j);
        }
        )
}
<span class="hljs-comment">//第一段程序输出10个10，第二段程序输出1,2,3,4,5,6,7,8,9；</span>
<span class="hljs-comment">//这是因为i为全局变量，每次循环使用的都是这同一个全局变量，而j是局部变量，只在当前此次循环有用，每次循环相当于新的变量。</span>
<span class="hljs-comment">//setTimeout函数每次执行相当于在主线程后添加事件，当前线程内执行完毕后，依次执行添加的事件。</span>
</code></pre></span><span i="32"><hr>
</span><span i="33"><h2 id="-const">② const</h2>
</span><span i="34"><p>const声明只读变量，声明后变量值不允许再改变，因此必须在声明时进行初始化。    </p>
</span><span i="36"><hr>
</span><span i="37"><p><strong>注：</strong>let和const在使用时会绑定代码块，即从声明这些变量的代码块的开始到结束形成一个封闭区，在这个作用域内，如果在声明这些变量之前使用这些变量，就会报错。<br><em>例：</em></p>
</span><span i="40"><pre><code>var <span class="hljs-built_in">PI</span> = <span class="hljs-string">"a"</span>;
<span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>){
  console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">PI</span>);  // ReferenceError: <span class="hljs-built_in">PI</span> is <span class="hljs-keyword">not</span> defined
  <span class="hljs-keyword">const</span> <span class="hljs-built_in">PI</span> = <span class="hljs-string">"3.1415926"</span>;
}
</code></pre></span><span i="46"><hr>
</span><span i="48"><h1 id="2-">2.解构</h1>
</span><span i="49"><h2 id="-">① 数组模型的解构</h2>
</span><span i="50"><pre><code>let [a,b,c] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<span class="hljs-comment">//a=1;b=2;c=3</span>

<span class="hljs-comment">//可忽略</span>
let [a, ,b] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<span class="hljs-comment">//a=1;b=3</span>

<span class="hljs-comment">//不完全解构</span>
let [a=<span class="hljs-number">1</span>,b] = [];<span class="hljs-comment">//a=1;b=undefined</span>

<span class="hljs-comment">//剩余运算符</span>
let [a, ...b] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<span class="hljs-comment">//a=1;b=[2,3]</span>
</code></pre></span><span i="60"><hr>
</span><span i="61"><h2 id="-">② 对象模型的解构</h2>
</span><span i="62"><pre><code><span class="hljs-keyword">let</span> {foo,bar} = {foo:<span class="hljs-string">'aaa'</span>, bar:<span class="hljs-string">'bbb'</span>};//foo=<span class="hljs-string">'aaa'</span>;bar=<span class="hljs-string">'bbb'</span>
<span class="hljs-keyword">let</span> {baz:foo} = {baz:<span class="hljs-string">'ddd'</span>};//foo=<span class="hljs-string">'ddd'</span>
</code></pre></span><span i="64"><hr>
</span><span i="65"><h1 id="3-symbol">3.原始数据类型Symbol</h1>
</span><span i="66"><p>每个Symbol值都是独一无二的：    </p>
</span><span i="68"><pre><code><span class="hljs-keyword">let</span> sy = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'kk'</span>);
consloe.log(sy);
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span>(sy));

<span class="hljs-keyword">let</span> sy1 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'kk'</span>);
<span class="hljs-built_in">console</span>.log(sy1);

<span class="hljs-built_in">console</span>.log(sy === sy1);

<span class="hljs-comment">/*
输出如下： 
Symbol(kk)
symbol
Symbol(kk)
false
*/</span>
</code></pre></span><span i="85"><p>由上可见，即使赋值相同，Symbol的返回值也不同。</p>
</span><span i="87"><hr>
</span><span i="89"><h2 id="-">可用于对象的属性名</h2>
</span><span i="90"><pre><code><span class="hljs-keyword">let</span> sy = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"key1"</span>);

<span class="hljs-comment">// 写法1</span>
<span class="hljs-keyword">let</span> syObject = {};
syObject[sy] = <span class="hljs-string">"kk"</span>;
<span class="hljs-built_in">console</span>.log(syObject);    <span class="hljs-comment">// {Symbol(key1): "kk"}</span>

<span class="hljs-comment">// 写法2</span>
<span class="hljs-keyword">let</span> syObject = {
  [sy]: <span class="hljs-string">"kk"</span>
};
<span class="hljs-built_in">console</span>.log(syObject);    <span class="hljs-comment">// {Symbol(key1): "kk"}</span>

<span class="hljs-comment">// 写法3</span>
<span class="hljs-keyword">let</span> syObject = {};
<span class="hljs-built_in">Object</span>.defineProperty(syObject, sy, {value: <span class="hljs-string">"kk"</span>});
<span class="hljs-built_in">console</span>.log(syObject);   <span class="hljs-comment">// {Symbol(key1): "kk"}</span>
</code></pre></span><span i="108"><p><strong>注：不知道为什么，输出时显示为空的大括号</strong></p>
</span><span i="110"><hr>
</span><span i="112"><h2 id="symbol-for-">Symbol.for()</h2>
</span><span i="113"><p>首先在全局搜寻已登记的Symbol中是否具有以该字符串为名称的Symbol值，有，则返回该值；没有，则新建并返回以该字符串为名称的Symbol值，并登记。</p>
</span><span i="115"><pre><code><span class="hljs-keyword">let</span> yellow = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"Yellow"</span>);
<span class="hljs-keyword">let</span> yellow1 = <span class="hljs-built_in">Symbol</span>.<span class="hljs-keyword">for</span>(<span class="hljs-string">"Yellow"</span>);
yellow === yellow1;      // <span class="hljs-literal">false</span>

<span class="hljs-keyword">let</span> yellow2 = <span class="hljs-built_in">Symbol</span>.<span class="hljs-keyword">for</span>(<span class="hljs-string">"Yellow"</span>);
yellow1 === yellow2;     // <span class="hljs-literal">true</span>
</code></pre></span><span i="121"><hr>
</span><span i="123"><h2 id="symbol-keyfor-">Symbol.keyFor()</h2>
</span><span i="124"><p>Symbol.keyFor() 返回一个已登记的 Symbol 类型值的 key ，用来检测该字符串参数作为名称的 Symbol 值是否已被登记。</p>
</span><span i="126"><pre><code><span class="hljs-keyword">let</span> yellow1 = <span class="hljs-built_in">Symbol</span>.<span class="hljs-keyword">for</span>(<span class="hljs-string">"Yellow"</span>);
<span class="hljs-built_in">Symbol</span>.keyFor(yellow1);    // <span class="hljs-string">"Yellow"</span>
</code></pre></span><span i="128"><hr>
</span><span i="130"><h1 id="4-map-">4.Map对象</h1>
</span><span i="131"><p> Map对象的键可以是任意值，object的键只能是字符串或者Symbol。    </p>
</span><span i="132"><h2 id="-map-key">① Map中的key</h2>
</span><span i="133"><pre><code> <span class="hljs-comment">//key是字符串</span>
<span class="hljs-keyword">var</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
<span class="hljs-keyword">var</span> keyString = <span class="hljs-string">"a string"</span>;

myMap.<span class="hljs-keyword">set</span>(keyString, <span class="hljs-string">"和键'a string'关联的值"</span>);

myMap.<span class="hljs-keyword">get</span>(keyString); <span class="hljs-comment">//"和键'a string'关联的值"</span>
myMap.<span class="hljs-keyword">get</span>(<span class="hljs-string">"a string"</span>); <span class="hljs-comment">//"和键'a string'关联的值"</span>
                       <span class="hljs-comment">//因为keyString === 'a string'</span>

<span class="hljs-comment">//key是NaN</span>
<span class="hljs-keyword">var</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
myMap.<span class="hljs-keyword">set</span>(NaN, <span class="hljs-string">"not a number"</span>);

myMap.<span class="hljs-keyword">get</span>(NaN); <span class="hljs-comment">// "not a number"</span>

<span class="hljs-keyword">var</span> otherNaN = Number(<span class="hljs-string">"foo"</span>);
myMap.<span class="hljs-keyword">get</span>(otherNaN); <span class="hljs-comment">// "not a number"  </span>
<span class="hljs-comment">//var otherNaN = Number("foo");</span>
<span class="hljs-comment">//myMap.set(otsherNaN, "other number 'foo'");</span>
<span class="hljs-comment">//myMap.get(otherNaN); // "other number 'foo'"</span>
<span class="hljs-comment">//myMap.get(Number("foo")); // "other number 'foo'"</span>
</code></pre></span><span i="156"><p><strong>虽然NaN和任何值甚至自己都不相等，但它作为Map的键来说是没有区别的</strong></p>
</span><span i="158"><hr>
</span><span i="159"><h2 id="-map-">② Map迭代</h2>
</span><span i="160"><p>对Map进行遍历，两种最高级方式：for...of 和 forEach().    </p>
</span><span i="162"><pre><code><span class="hljs-comment">//for...of</span>
<span class="hljs-keyword">let</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
myMap.set(<span class="hljs-number">0</span>,<span class="hljs-string">"zero"</span>);
myMap.set(<span class="hljs-number">1</span>,<span class="hljs-string">"one"</span>);

<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> [key,value] <span class="hljs-keyword">of</span> myMap)
{
    <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">"="</span> + value);
} <span class="hljs-comment">// 显示 0=zero, 1=one</span>

<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> [key,value] <span class="hljs-keyword">of</span> myMap.entries())
{
      <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">" = "</span> + value);
} <span class="hljs-comment">// 显示 0=zero, 1=one</span>
<span class="hljs-comment">//这个entires方法返回一个新的容器(Iterator)对象，它按插入顺序包含了Map对象中每个[key,value]数组</span>

<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> myMap.keys())
  {
    <span class="hljs-built_in">console</span>.log(key);
  } <span class="hljs-comment">//显示 0, 1</span>

<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> myMap.values())
  {
    <span class="hljs-built_in">console</span>.log(value);
  } <span class="hljs-comment">// 显示 zero, one</span>


<span class="hljs-comment">//forEach()</span>
<span class="hljs-keyword">let</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
myMap.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value,key</span>)</span>{
    <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">" = "</span> + value);
}) <span class="hljs-comment">//显示 0=zero, 1=one</span>
<span class="hljs-comment">//注意function后面的参数，前面是value，后面是key</span>
</code></pre></span><span i="196"><hr>
</span><span i="198"><h2 id="-map-">③ Map对象的操作</h2>
</span><span i="199"><h3 id="map-array-">Map与数组(Array)的转换</h3>
</span><span i="200"><pre><code><span class="hljs-keyword">let</span> kvArray = [[<span class="hljs-string">"key1"</span>, <span class="hljs-string">"value1"</span>], [<span class="hljs-string">"key2"</span>, <span class="hljs-string">"value2"</span>]];

<span class="hljs-keyword">let</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(kvArray);
<span class="hljs-comment">//将二维键值对数组转化为Map对象</span>

<span class="hljs-keyword">let</span> outArray = <span class="hljs-built_in">Array</span>.from(myMap);
<span class="hljs-comment">//使用Array.from()函数，将Map对象转化为一个二维键值对数组</span>
</code></pre></span><span i="208"><h3 id="map-">Map的克隆</h3>
</span><span i="210"><pre><code><span class="hljs-keyword">let</span> myMap1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">"key1"</span>, <span class="hljs-string">"value1"</span>], [<span class="hljs-string">"key2"</span>, <span class="hljs-string">"value2"</span>]]);

<span class="hljs-keyword">let</span> myMap2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(myMap1);
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> myMap2)
  {
    <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">" = "</span> + value);
  } <span class="hljs-comment">// 打印 key1 = value1, key2 = value2</span>

<span class="hljs-built_in">console</span>.log(myMap1 === myMap2); <span class="hljs-comment">// 打印 false,Map 对象构造函数生成实例，迭代出新的对象</span>
</code></pre></span><span i="220"><h3 id="map-">Map的合并</h3>
</span><span i="222"><pre><code><span class="hljs-keyword">let</span> myMap1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-number">1</span>, <span class="hljs-string">'one'</span>], [<span class="hljs-number">2</span>, <span class="hljs-string">'two'</span>], [<span class="hljs-number">3</span>, <span class="hljs-string">'three'</span>]]);
<span class="hljs-keyword">let</span> myMap2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-number">1</span>, <span class="hljs-string">'uno'</span>], [<span class="hljs-number">2</span>, <span class="hljs-string">'dos'</span>]]);

<span class="hljs-keyword">let</span> myMap3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([...myMap1, ...myMap2]);

<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> [key,value] <span class="hljs-keyword">of</span> myMap3)
  {
    <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">" = "</span> + value);
  } <span class="hljs-comment">// 打印 1 = uno, 2 = dos, 3 = three</span>
<span class="hljs-comment">//融合时，当有键重复时，后面的键值覆盖前面的键值</span>
</code></pre></span><span i="233"><h1 id="5-set-">5. Set对象</h1>
</span><span i="234"><p>Set对象可存储不同类型的值，但存储的值是唯一的，不能重复。<br><strong>几种特殊值：</strong>    </p>
</span><span i="236"><ul>
<li><span i="236">+0和-0是恒等的，不重复    </span></li>
<li><span i="237">undefined和undefined是恒等的，不重复    </span></li>
<li><span i="238">NaN和NaN不恒等，但Set中只能存一个，不重复        </span></li>
</ul>
</span><span i="242"><pre><code>let mySet = <span class="hljs-keyword">new</span> Set();
mySet.<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>);
mySet.<span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>);
mySet.<span class="hljs-built_in">add</span>(<span class="hljs-number">5</span>);
mySet.<span class="hljs-built_in">add</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 打印 Set(3) {1, 2, 5}，5不重复</span>
console.<span class="hljs-built_in">log</span>(mySet);
mySet.<span class="hljs-built_in">add</span>(<span class="hljs-string">'some text'</span>);
console.<span class="hljs-built_in">log</span>(mySet);<span class="hljs-comment">// 打印 Set(4) {1, 2, 5, "some text"}，可存储不同类型的值</span>

let o = {<span class="hljs-string">'a'</span>:<span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>:<span class="hljs-number">2</span>};
mySet.<span class="hljs-built_in">add</span>(o);
mySet.<span class="hljs-built_in">add</span>({<span class="hljs-string">'a'</span>:<span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>:<span class="hljs-number">2</span>});
console.<span class="hljs-built_in">log</span>(mySet); <span class="hljs-comment">// 打印 Set(6) {1, 2, 5, "some text", {…}, …}, 对象之间即使值相同，引用不同也不恒等</span>
                    <span class="hljs-comment">//4: value: {a: 1, b: 2}; 5: value: {a: 1, b: 2}</span>
</code></pre></span><span i="257"><h2 id="set-">Set对象与数组的转换</h2>
</span><span i="259"><pre><code><span class="hljs-keyword">var</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">'value1'</span>, <span class="hljs-string">'value2'</span>, <span class="hljs-string">'value3'</span>]);
<span class="hljs-comment">//注意初始化时若要同时赋几个值，是有中括号的，否则会将赋的字符串转化为单个字符</span>

<span class="hljs-keyword">var</span> outArray = [...mySet]; <span class="hljs-comment">// 利用[...Set]将Set对象转化为数组</span>
<span class="hljs-built_in">console</span>.log(outArray); <span class="hljs-comment">// 打印 (3) [“value1”, “value2”, “value3”]</span>
</code></pre></span><span i="265"><h2 id="string-set">String转Set</h2>
</span><span i="267"><pre><code><span class="hljs-keyword">var</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(<span class="hljs-string">'hello'</span>);
<span class="hljs-comment">// 注：Set 中 toString 方法是不能将 Set 转换成 String</span>
<span class="hljs-built_in">console</span>.log(mySet); <span class="hljs-comment">// 打印 ‘h’ ‘e’ ‘l’ ‘o’</span>
</code></pre></span><span i="271"><h2 id="set-">Set对象的应用</h2>
</span><span i="273"><pre><code><span class="hljs-comment">// 数组去重</span>
<span class="hljs-keyword">var</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]);
<span class="hljs-keyword">var</span> outArray = [...mySet];
<span class="hljs-built_in">console</span>.log(outArray); <span class="hljs-comment">// 打印 (6) [1, 2, 3, 4, 5, 6]</span>

<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);
<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]);

<span class="hljs-comment">// 求并集</span>
<span class="hljs-keyword">var</span> union = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...a, ...b]);
<span class="hljs-built_in">console</span>.log(union); <span class="hljs-comment">// 打印 Set(4) {1, 2, 3, 4}</span>

<span class="hljs-comment">// 求交集</span>
<span class="hljs-keyword">var</span> intersect = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...a].filter(x =&gt; b.has(x)));
<span class="hljs-built_in">console</span>.log(intersect); <span class="hljs-comment">// 打印 Set(2) {2, 3}</span>

<span class="hljs-comment">// 求a与b的差集</span>
<span class="hljs-keyword">var</span> difference_a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...a].filter(x =&gt; !b.has(x)));
<span class="hljs-built_in">console</span>.log(difference_a); <span class="hljs-comment">// 打印 Set(1) {1}</span>

<span class="hljs-comment">// 求b与a的差集</span>
<span class="hljs-keyword">var</span> difference_b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...b].filter(x =&gt; !a.has(x)));
<span class="hljs-built_in">console</span>.log(difference_b); <span class="hljs-comment">// 打印 Set(1) {4}</span>
</code></pre></span><span i="297"><hr>
</span><span i="299"><h1 id="6-proxy-reflect">6. Proxy和Reflect</h1>
</span><span i="300"><p>Proxy 可以对目标对象的读取、函数调用等操作进行拦截，然后进行操作处理。它不直接操作对象，而是像代理模式，通过对象的代理对象进行操作，在进行这些操作时，可以添加一些需要的额外操作。<br>Reflect 可以用于获取目标对象的行为，它与 Object 类似，但是更易读。它的方法与 Proxy 是对应的。</p>
</span><span i="303"><hr>
</span><span i="304"><h2 id="-proxy">① Proxy</h2>
</span><span i="305"><p>一个Proxy对象由两部分组成，target和handler。<br>target即目标对象，handler是一个对象，声明了代理对象target的指定行为。</p>
</span><span i="308"><h3 id="-">一般用法：</h3>
</span><span i="309"><pre><code><span class="hljs-keyword">let</span> target = {
  name : <span class="hljs-string">"Tom"</span>,
  age : <span class="hljs-number">25</span>
}

<span class="hljs-keyword">let</span> handler = {
  get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, key</span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'getting '</span> + key);
    <span class="hljs-keyword">return</span> target[key]; <span class="hljs-comment">//注意此处不是target.key，而是target[key]</span>
  }, <span class="hljs-comment">//注意此处要加逗号而不是分号</span>
  set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, value</span>)</span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'setting '</span> + key);
  target[key] = value;
  }
}

<span class="hljs-keyword">let</span> myProxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);
<span class="hljs-built_in">console</span>.log(myProxy.name); <span class="hljs-comment">// 打印 Tom；实际执行 handler.get</span>
myProxy.name = <span class="hljs-string">'John'</span>; <span class="hljs-comment">// 实际执行 handler.set</span>
<span class="hljs-built_in">console</span>.log(myProxy.name); <span class="hljs-comment">// 打印 John</span>

<span class="hljs-comment">//target 可以为空对象</span>
<span class="hljs-keyword">let</span> targetEpt = {};
<span class="hljs-keyword">let</span> proxyEpt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(targetEpt, handler);
<span class="hljs-built_in">console</span>.log(proxyEpt.name); <span class="hljs-comment">// 打印 undefined；调用get方法，此时对象为空，没有name属性</span>
proxyEpt.name = <span class="hljs-string">'John'</span>; <span class="hljs-comment">// 调用set方法，向对象添加了name属性</span>
<span class="hljs-built_in">console</span>.log(targetEpt.name); <span class="hljs-comment">// 打印John</span>
<span class="hljs-comment">// 通过构造函数新建实例时，相当于对目标对象进行了浅拷贝，因此目标对象和代理对象会相互影响</span>

<span class="hljs-comment">// handler 对象也可以为空，相当于不设置拦截操作，直接访问目标对象</span>
<span class="hljs-keyword">let</span> targetEmpty = {};
<span class="hljs-keyword">let</span> proxyEmpty = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(targetEmpty, {});
<span class="hljs-built_in">console</span>.log(proxyEmpty.name); <span class="hljs-comment">// 打印 undefined</span>
proxyEmpty.name = <span class="hljs-string">'Jenny'</span>; <span class="hljs-comment">// 直接对目标对象进行操作</span>
<span class="hljs-built_in">console</span>.log(targetEmpty.name); <span class="hljs-comment">// 打印Jenny</span>
</code></pre></span><span i="345"><hr>
</span><span i="346"><h3 id="-">实例方法：</h3>
</span><span i="347"><p><strong>get(target, propKey, receiver)</strong>    </p>
</span><span i="349"><pre><code><span class="hljs-comment">// 用于target对象上propKey的读取操作</span>
<span class="hljs-keyword">let</span> exam ={
    name: <span class="hljs-string">"Tom"</span>,
    age: <span class="hljs-number">24</span>
}
<span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(exam, {
  get(target, propKey, receiver) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Getting '</span> + propKey);
    <span class="hljs-keyword">return</span> target[propKey];
  }
})
<span class="hljs-built_in">console</span>.log(proxy.name); <span class="hljs-comment">// 打印 Tom</span>

<span class="hljs-comment">// get方法可以继承</span>
<span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.create(proxy);
<span class="hljs-built_in">console</span>.log(obj.name); <span class="hljs-comment">// 打印 Tom</span>
</code></pre></span><span i="366"><hr>
</span><span i="367"><p><strong>set(target, propKey, value, receiver)</strong>    </p>
</span><span i="369"><pre><code><span class="hljs-comment">//用于拦截 target 对象上的 propKey 的赋值操作。如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用。</span>
<span class="hljs-keyword">let</span> validator = {
    set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj, prop, value</span>) </span>{
        <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'age'</span>) {
            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Number</span>.isInteger(value)) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'The age is not an integer'</span>);
            }
            <span class="hljs-keyword">if</span> (value &gt; <span class="hljs-number">200</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RangeError</span>(<span class="hljs-string">'The age seems invalid'</span>);
            }
        }
        <span class="hljs-comment">// 对于满足条件的 age 属性以及其他属性，直接保存</span>
        obj[prop] = value;
    }
};
<span class="hljs-keyword">let</span> proxy= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({}, validator)
proxy.age = <span class="hljs-number">100</span>;
proxy.age           <span class="hljs-comment">// 100</span>
proxy.age = <span class="hljs-string">'oppps'</span> <span class="hljs-comment">// 报错 The age is not an integer</span>
proxy.age = <span class="hljs-number">300</span>     <span class="hljs-comment">// 报错 The age seems invalid</span>

<span class="hljs-comment">// 参数 receiver 表示原始操作行为所在对象，一般是 Proxy 实例本身</span>
<span class="hljs-keyword">const</span> handler = {
    set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj, prop, value, receiver</span>) </span>{
        obj[prop] = receiver;
    }
};
<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({}, handler);
proxy.name= <span class="hljs-string">'Tom'</span>;
<span class="hljs-built_in">console</span>.log(proxy); <span class="hljs-comment">// 打印 Proxy {name: Proxy}</span>
<span class="hljs-built_in">console</span>.log(proxy.name=== proxy); <span class="hljs-comment">// 打印 true</span>
</code></pre></span><span i="401"><hr>
</span><span i="402"><p><strong>apply(target, ctx, args)</strong>    </p>
</span><span i="404"><pre><code><span class="hljs-comment">// 用于拦截函数的调用、call 和 reply 操作。target 表示目标对象，ctx 表示目标对象上下文，args 表示目标对象的参数数组</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sub</span>(<span class="hljs-params">a, b</span>)</span>{
    <span class="hljs-keyword">return</span> a - b;
}
<span class="hljs-keyword">let</span> handler = {
    apply: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, ctx, args</span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'handle apply'</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.apply(...arguments);
    }
}
<span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(sub, handler);
<span class="hljs-built_in">console</span>.log(proxy(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>));  <span class="hljs-comment">// 打印 1</span>
</code></pre></span><span i="417"><hr>
</span><span i="418"><p><strong>has(target, propKey)</strong>    </p>
</span><span i="420"><pre><code><span class="hljs-comment">//用于拦截 HasProperty 操作，即在判断 target 对象是否存在 propKey 属性时，会被这个方法拦截。此方法不判断一个属性是对象自身的属性，还是继承的属性</span>
<span class="hljs-keyword">let</span>  handler = {
    has: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, propKey</span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"handle has"</span>);
        <span class="hljs-keyword">return</span> propKey <span class="hljs-keyword">in</span> target;
    }
}
<span class="hljs-keyword">let</span> exam = {name: <span class="hljs-string">"Tom"</span>};
<span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(exam, handler);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'name'</span> <span class="hljs-keyword">in</span> proxy); <span class="hljs-comment">// 打印 true</span>
<span class="hljs-comment">//注意：此方法不拦截 for ... in 循环</span>
</code></pre></span><span i="432"><hr>
</span><span i="433"><p><strong>construct(target, args)</strong></p>
</span><span i="435"><pre><code><span class="hljs-comment">// 用于拦截new命令。返回值必须为对象</span>
<span class="hljs-keyword">let</span> handler = {
    construct: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, args, newTarget</span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"handle construct"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.construct(target, args, newTarget);
    } }
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exam</span>(<span class="hljs-params">name,age</span>)</span>{
            <span class="hljs-keyword">this</span>.name = name;
              <span class="hljs-keyword">this</span>.age = age;
        }

<span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(exam,handler)
<span class="hljs-keyword">let</span> stu = <span class="hljs-keyword">new</span> proxy(<span class="hljs-string">"Tom"</span>,<span class="hljs-number">25</span>); <span class="hljs-comment">// 相当于生成下面stu1对象的过程</span>
<span class="hljs-built_in">console</span>.log(stu); <span class="hljs-comment">// 打印 exam {name: "Tom", age: 25}</span>

<span class="hljs-keyword">let</span> stu1 = <span class="hljs-keyword">new</span> exam(<span class="hljs-string">'John'</span>, <span class="hljs-number">24</span>);
<span class="hljs-built_in">console</span>.log(stu1); <span class="hljs-comment">// 打印 exam {name: "John", age: 24}</span>
</code></pre></span><span i="453"><hr>
</span><span i="454"><p><strong>deleteProperty(target, propKey)</strong><br><em>用于拦截 delete 操作，如果这个方法抛出错误或者返回 false ，propKey 属性就无法被 delete 命令删除</em></p>
</span><span i="457"><hr>
</span><span i="458"><p><strong>defineProperty(target, propKey, propDesc)</strong></p>
</span><span i="460"><pre><code><span class="hljs-comment">// 用于拦截 Object.definePro若目标对象不可扩展，增加目标对象上不存在的属性会报错；若属性不可写或不可配置，则不能改变这些属性</span>
<span class="hljs-keyword">let</span> handler = {
    defineProperty: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, propKey, propDesc</span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"handle defineProperty"</span>);
          <span class="hljs-comment">//target[propKey] = propDesc;</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
}
<span class="hljs-keyword">let</span> target = {}
<span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler)
proxy.name = <span class="hljs-string">"Tom"</span>
<span class="hljs-comment">// handle defineProperty</span>
<span class="hljs-built_in">console</span>.log(target);
<span class="hljs-comment">// 应该显示{name: "Tom"}</span>
</code></pre></span><span i="474"><p><strong>但不知道为什么显示为空：{}</strong></p>
</span><span i="476"><pre><code><span class="hljs-comment">// defineProperty 返回值为false，添加属性操作无效</span>
<span class="hljs-keyword">let</span> handler1 = {
    defineProperty: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, propKey, propDesc</span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"handle defineProperty"</span>);
          <span class="hljs-comment">//target[propKey] = propDesc;</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
}
<span class="hljs-keyword">let</span> target1 = {}
<span class="hljs-keyword">let</span> proxy1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target1, handler1)
proxy1.name = <span class="hljs-string">"Jerry"</span>
<span class="hljs-built_in">console</span>.log(target1); <span class="hljs-comment">//显示为空{}</span>
</code></pre></span><span i="489"><hr>
</span><span i="490"><p><strong>getOwnPropertyDescriptor(target, propKey)</strong>    </p>
</span><span i="492"><pre><code><span class="hljs-comment">// 用于拦截 Object.getOwnPropertyD() 返回值为属性描述对象或者 undefined </span>
<span class="hljs-keyword">let</span> handler = {
    getOwnPropertyDescriptor: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, propKey</span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(target, propKey);
    }
}
<span class="hljs-keyword">let</span> target = {name: <span class="hljs-string">"Tom"</span>};
<span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="hljs-string">'name'</span>)); <span class="hljs-comment">// 打印 {value: "Tom", writable: true, enumerable: true, configurable: true}</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="hljs-string">'age'</span>)); <span class="hljs-comment">// 打印 undefined</span>
</code></pre></span><span i="503"><hr>
</span><span i="504"><p><strong>getPrototypeOf(target)</strong>    </p>
</span><span i="506"><pre><code><span class="hljs-comment">// 主要用于拦截获取对象原型的操作。包括以下操作：</span>
- <span class="hljs-built_in">Object</span>.prototype._proto_
- <span class="hljs-built_in">Object</span>.prototype.isPrototypeOf()
- <span class="hljs-built_in">Object</span>.getPrototypeOf()
- <span class="hljs-built_in">Reflect</span>.getPrototypeOf()
- <span class="hljs-keyword">instanceof</span>

<span class="hljs-comment">// 代码如下：</span>
<span class="hljs-keyword">let</span> exam = {name : <span class="hljs-string">'Tom'</span> , age : <span class="hljs-number">25</span>};
<span class="hljs-keyword">let</span> exam1 = {};
<span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({},{
    getPrototypeOf: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target</span>)</span>{
        <span class="hljs-keyword">return</span> exam;
    }
})

    <span class="hljs-keyword">let</span> proxy1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({},{
    getPrototypeOf: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target</span>)</span>{
        <span class="hljs-keyword">return</span> exam1;
    }
})

<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(proxy)); <span class="hljs-comment">// 打印 {name: "Tom", age: 25}</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(proxy1)); <span class="hljs-comment">// 打印 {}</span>

<span class="hljs-comment">// 注意，返回值必须是对象或者 null ，否则报错。另外，如果目标对象不可扩展（non-extensible），getPrototypeOf 方法必须返回目标对象的原型对象</span>
<span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({},{
    getPrototypeOf: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target</span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
})
<span class="hljs-built_in">Object</span>.getPrototypeOf(proxy); <span class="hljs-comment">// 报错 Uncaught TypeError: 'getPrototypeOf' on proxy: trap returned neither object nor null</span>
</code></pre></span><span i="539"><hr>
</span><span i="540"><p><strong>isExtensible(target)</strong>    </p>
</span><span i="542"><pre><code><span class="hljs-comment">// 用于拦截 Object.isExtensible 操作。</span>
<span class="hljs-comment">// 该方法只能返回布尔值，否则返回值会被自动转为布尔值。</span>
<span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({},{
    isExtensible:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target</span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
})
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.isExtensible(proxy)); <span class="hljs-comment">// 打印 true</span>

<span class="hljs-comment">// 注意它的返回值必须与目标对象的isExtensible属性保持一致，否则会抛出错误:</span>
<span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({},{
    isExtensible:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target</span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
})
<span class="hljs-built_in">Object</span>.isExtensible(proxy); <span class="hljs-comment">// 报错 Uncaught TypeError: 'isExtensible' on proxy: trap result does not reflect extensibility of proxy target (which is 'true') at Function.isExtensible </span>
</code></pre></span><span i="559"><hr>
</span><span i="560"><p><strong>ownKeys(target)</strong>    </p>
</span><span i="562"><pre><code><span class="hljs-comment">// 用于拦截对象自身属性的读取操作。主要包括以下操作：</span>
- <span class="hljs-built_in">Object</span>.getOwnPropertyNames()
- <span class="hljs-built_in">Object</span>.getOwnPropertySymbols()
- <span class="hljs-built_in">Object</span>.keys()
- or...in

<span class="hljs-comment">// 方法返回的数组成员，只能是字符串或 Symbol 值，否则会报错。</span>
<span class="hljs-comment">// 若目标对象中含有不可配置的属性，则必须将这些属性在结果中返回，否则就会报错。</span>
<span class="hljs-comment">// 若目标对象不可扩展，则必须全部返回且只能返回目标对象包含的所有属性，不能包含不存在的属性，否则也会报错。</span>
<span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>( {
  name: <span class="hljs-string">"Tom"</span>,
  age: <span class="hljs-number">24</span>
}, {
    ownKeys(target) {
        <span class="hljs-keyword">return</span> [<span class="hljs-string">'name'</span>];
    }
});
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(proxy)); <span class="hljs-comment">// 打印 ["name"]</span>

<span class="hljs-comment">/* 
返回结果中，三类属性会被过滤：
      - 目标对象上没有的属性
      - 属性名为 Symbol 值的属性
      - 不可遍历的属性
 */</span>
 <span class="hljs-keyword">let</span> target = {
  name: <span class="hljs-string">"Tom"</span>,
  [<span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'age'</span>)]: <span class="hljs-number">24</span>,
};
<span class="hljs-comment">// 添加不可遍历属性 'gender'</span>
<span class="hljs-built_in">Object</span>.defineProperty(target, <span class="hljs-string">'gender'</span>, {
  enumerable: <span class="hljs-literal">false</span>,
  configurable: <span class="hljs-literal">true</span>,
  writable: <span class="hljs-literal">true</span>,
  value: <span class="hljs-string">'male'</span>
});
<span class="hljs-keyword">let</span> handler = {
    ownKeys(target) {
        <span class="hljs-keyword">return</span> [<span class="hljs-string">'name'</span>, <span class="hljs-string">'parent'</span>, <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'age'</span>), <span class="hljs-string">'gender'</span>];
    }
};
<span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(proxy)); <span class="hljs-comment">// 打印 ["name"]; 只有name属性被返回，其他被过滤了</span>
</code></pre></span><span i="606"><hr>
</span><span i="607"><p><strong>preventExtensions(target)</strong>    </p>
</span><span i="609"><pre><code><span class="hljs-comment">// 拦截 Object.preventExtensions 操作。</span>
<span class="hljs-comment">// 该方法必须返回一个布尔值，否则会自动转为布尔值。</span>

<span class="hljs-comment">// 只有目标对象不可扩展时（即 Object.isExtensible(proxy) 为 false ），proxy.preventExtensions 才能返回 true ，否则会报错</span>

<span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({}, {
  preventExtensions: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
});
<span class="hljs-comment">// 由于 proxy.preventExtensions 返回 true，此处也会返回 true，因此会报错</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.preventExtensions(proxy)); <span class="hljs-comment">// 报错 Uncaught TypeError: 'preventExtensions' on proxy: trap returned truish but the proxy target is extensible at Function.preventExtensions </span>
</code></pre></span><span i="621"><h4 id="-target-object-isextensible-proxy-true-"><em>应该是由于target可扩展，即Object.isExtensible(proxy) 为true，所以冲突才报错吧，不太理解</em></h4>
</span><span i="623"><pre><code><span class="hljs-comment">// 修改如下：</span>
 <span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({}, {
  preventExtensions: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target</span>) </span>{
    <span class="hljs-comment">// 返回前先调用 Object.preventExtensions</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.preventExtensions(target)); <span class="hljs-comment">// 打印{}</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
});
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.preventExtensions(proxy)); <span class="hljs-comment">// 打印 Proxy {}</span>
</code></pre></span><span i="633"><hr>
</span><span i="634"><p><strong>setPrototypeOf</strong>    </p>
</span><span i="636"><pre><code><span class="hljs-comment">// 主要用来拦截 Object.setPrototypeOf 方法。</span>
<span class="hljs-comment">// 返回值必须为布尔值，否则会被自动转为布尔值。</span>
<span class="hljs-comment">// 若目标对象不可扩展，setPrototypeOf 方法不得改变目标对象的原型。</span>
<span class="hljs-keyword">let</span> proto = {}
<span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}, {
    setPrototypeOf: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, proto</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"setPrototypeOf"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
});
<span class="hljs-built_in">Object</span>.setPrototypeOf(proxy, proto);
<span class="hljs-comment">// 结果中打印 setPrototypeOf</span>
</code></pre></span><span i="649"><hr>
</span><span i="650"><p><strong>Proxy.revocable()</strong>    </p>
</span><span i="652"><pre><code><span class="hljs-comment">// 用于返回一个可取消的 Proxy 实例</span>
<span class="hljs-keyword">let</span> {proxy, revoke} = <span class="hljs-built_in">Proxy</span>.revocable({}, {});
proxy.name = <span class="hljs-string">"Tom"</span>;
revoke();
proxy.name; <span class="hljs-comment">// 报错 TypeError: Cannot perform 'get' on a proxy that has been revoked</span>
</code></pre></span><span i="658"><hr>
</span><span i="659"><h2 id="-reflect">② Reflect</h2>
</span><span i="660"><p>ES6 中将 Object 的一些明显属于语言内部的方法移植到了 Reflect 对象上（当前某些方法会同时存在于 Object 和 Reflect 对象上），未来的新方法会只部署在 Reflect 对象上。<br>Reflect 对象对某些方法的返回结果进行了修改，使其更合理。<br>Reflect 对象使用函数的方式实现了 Object 的命令式操作。</p>
</span><span i="664"><h3 id="-">静态方法</h3>
</span><span i="665"><p><strong>Reflect.get(target, name, receiver)</strong>    </p>
</span><span i="667"><pre><code><span class="hljs-comment">// 查找并返回 target 对象的 name 属性</span>
<span class="hljs-keyword">let</span> exam = {
    name: <span class="hljs-string">"Tom"</span>,
    age: <span class="hljs-number">24</span>,
    get info(){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name + <span class="hljs-keyword">this</span>.age;
    }
}
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.get(exam, <span class="hljs-string">'name'</span>)); <span class="hljs-comment">// 打印 Tom</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.get(exam, <span class="hljs-string">'age'</span>));  <span class="hljs-comment">// 打印 24</span>

<span class="hljs-comment">// 当 target 对象中存在 name 属性的 getter 方法， getter 方法的 this 会绑定 receiver</span>
<span class="hljs-keyword">let</span> receiver = {
    name: <span class="hljs-string">"Jerry"</span>,
    age: <span class="hljs-number">20</span>
}
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.get(exam, <span class="hljs-string">'info'</span>, receiver)); <span class="hljs-comment">// 打印 Jerry20； </span>
<span class="hljs-comment">//打印的结果为receiver对象中的内容而不是exam对象中的内容，这是因为getter方法的this绑定了receiver</span>

<span class="hljs-comment">// 当 name 为不存在于 target 对象的属性时，返回 undefined</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.get(exam, <span class="hljs-string">'birth'</span>)); <span class="hljs-comment">// 打印 undefined</span>

<span class="hljs-comment">// 当 target 不是对象时，会报错</span>
<span class="hljs-built_in">Reflect</span>.get(<span class="hljs-number">1</span>, <span class="hljs-string">'name'</span>); <span class="hljs-comment">// 报错 Uncaught TypeError: Reflect.get called on non-object</span>
</code></pre></span><span i="692"><hr>
</span><span i="693"><p><strong>Reflect.set(target, name, value, receiver)</strong>    </p>
</span><span i="695"><pre><code><span class="hljs-comment">// 将 target 的 name 属性设置为 value。返回值为 boolean ，true 表示修改成功，false 表示失败。当 target 为不存在的对象时，会报错</span>
<span class="hljs-keyword">let</span> exam = {
    name: <span class="hljs-string">"Tom"</span>,
    age: <span class="hljs-number">24</span>,
    set info(value){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age = value;
    }
}
<span class="hljs-built_in">console</span>.log(exam.age); <span class="hljs-comment">// 打印 24</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.set(exam, <span class="hljs-string">'age'</span>, <span class="hljs-number">25</span>)); <span class="hljs-comment">// 打印 true</span>
<span class="hljs-built_in">console</span>.log(exam.age); <span class="hljs-comment">// 打印 25</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.set(exam, <span class="hljs-string">'color'</span>, <span class="hljs-string">'blue'</span>)); <span class="hljs-comment">// 打印 true</span>
<span class="hljs-built_in">console</span>.log(exam.color); <span class="hljs-comment">// 打印 blue</span>

<span class="hljs-comment">// value 为空时会将 name 属性清除</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.set(exam, <span class="hljs-string">'age'</span>, )); <span class="hljs-comment">// 打印 true</span>
<span class="hljs-built_in">console</span>.log(exam.age); <span class="hljs-comment">// 打印 undefined</span>

<span class="hljs-comment">// 当 target 对象中存在 name 属性 setter 方法时，setter 方法中的 this 会绑定 // receiver , 所以修改的实际上是 receiver 的属性,</span>
<span class="hljs-keyword">let</span> receiver = {
    age: <span class="hljs-number">18</span>
}
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.set(exam, <span class="hljs-string">'info'</span>, <span class="hljs-number">1</span>, receiver)); <span class="hljs-comment">// 打印 true</span>
<span class="hljs-built_in">console</span>.log(receiver.age); <span class="hljs-comment">// 打印 1</span>
<span class="hljs-built_in">console</span>.log(exam.age); <span class="hljs-comment">// 打印 undefined；因为实际上修改的是receiver的属性，所以exam属性不变</span>

<span class="hljs-keyword">let</span> receiver1 = {
    name: <span class="hljs-string">'oppps'</span>
}
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.set(exam, <span class="hljs-string">'info'</span>, <span class="hljs-number">1</span>, receiver1)); <span class="hljs-comment">// 打印 true</span>
<span class="hljs-built_in">console</span>.log(receiver1.age); <span class="hljs-comment">// 打印 1；以为setter方法只设置age属性</span>
</code></pre></span><span i="727"><hr>
</span><span i="728"><p><strong>Reflect.has(obj, name)</strong>    </p>
</span><span i="730"><pre><code><span class="hljs-comment">// 是 name in obj 指令的函数化，用于查找 name 属性在 obj 对象中是否存在。返回值为 boolean。如果 obj 不是对象则会报错 TypeError</span>
<span class="hljs-keyword">let</span> exam = {
    name: <span class="hljs-string">"Tom"</span>,
    age: <span class="hljs-number">24</span>
}
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.has(exam, <span class="hljs-string">'name'</span>)); <span class="hljs-comment">// 打印 true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.has(exam, <span class="hljs-string">'color'</span>)); <span class="hljs-comment">// 打印 false</span>
</code></pre></span><span i="738"><hr>
</span><span i="739"><p><strong>Reflect.deleteProperty(obj, property)</strong>    </p>
</span><span i="741"><pre><code>// 是 delete obj[<span class="hljs-keyword">property</span><span class="hljs-title"></span>] 的函数化，用于删除 obj 对象的 <span class="hljs-keyword">property</span><span class="hljs-title"> </span>属性，返回值为 boolean。如果 obj 不是对象则会报错 TypeError    
let exam = {
    name: <span class="hljs-string">"Tom"</span>,
    age: <span class="hljs-number">24</span>
}
Reflect.deleteProperty(exam , 'name'); // <span class="hljs-literal">true</span>
console.log(exam); // 打印 {age: <span class="hljs-number">24</span>}

// <span class="hljs-keyword">property</span><span class="hljs-title"> </span>不存在时，也会返回 <span class="hljs-literal">true</span>
Reflect.deleteProperty(exam , 'name'); // <span class="hljs-literal">true</span>
</code></pre></span><span i="752"><hr>
</span><span i="753"><p><strong>Reflect.construct(obj, args)</strong>    </p>
</span><span i="755"><pre><code><span class="hljs-comment">// 等同于 new target(...args)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exam</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">this</span>.name = name;
}
<span class="hljs-built_in">Reflect</span>.construct(exam, [<span class="hljs-string">'Tom'</span>]); <span class="hljs-comment">// exam {name: "Tom"}</span>
</code></pre></span><span i="761"><hr>
</span><span i="762"><p><strong>Reflect.getPrototypeOf(obj)</strong>    </p>
</span><span i="764"><pre><code><span class="hljs-comment">// 用于读取 obj 的 _proto_ 属性。在 obj 不是对象时不会像 Object 一样把 obj 转为对象，而是会报错</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Exam</span></span>{}
<span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> Exam()
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.getPrototypeOf(obj) === Exam.prototype); <span class="hljs-comment">// 打印 true</span>
</code></pre></span><span i="769"><hr>
</span><span i="770"><p><strong>Reflect.setPrototypeOf(obj, newProto)</strong>    </p>
</span><span i="772"><pre><code>// 用于设置目标对象的 proto<span class="hljs-keyword">type</span>
<span class="hljs-title">let</span> obj ={}
<span class="hljs-type">Reflect</span>.setPrototypeOf(obj, <span class="hljs-type">Array</span>.prototype); // true;将obj对象prototype设置为<span class="hljs-type">Array</span>
</code></pre></span><span i="776"><hr>
</span><span i="777"><p><strong>Reflect.apply(func, thisArg, args)</strong> </p>
</span><span i="779"><pre><code><span class="hljs-comment">// 等同于 Function.prototype.apply.call(func, thisArg, args) 。func 表示目标函数；thisArg 表示目标函数绑定的 this 对象；args 表示目标函数调用时传入的参数列表，可以是数组或类似数组的对象。若目标函数无法调用，会抛出 TypeError</span>
Reflect.apply(Math.max, Math, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>]); <span class="hljs-comment">// 5</span>
</code></pre></span><span i="782"><hr>
</span><span i="783"><p><strong>Reflect.defineProperty(target, propertyKey, attributes)</strong>    </p>
</span><span i="785"><pre><code><span class="hljs-comment">// 用于为目标对象定义属性。如果 target 不是对象，会抛出错误</span>
<span class="hljs-keyword">let</span> myDate= {}
<span class="hljs-built_in">Reflect</span>.defineProperty(MyDate, <span class="hljs-string">'now'</span>, {
  value: () =&gt; <span class="hljs-built_in">Date</span>.now()
}); <span class="hljs-comment">// true</span>
</code></pre></span><span i="791"><hr>
</span><span i="792"><p><strong>Reflect.getOwnPropertyDescriptor(target, propertyKey)</strong>    </p>
</span><span i="794"><pre><code><span class="hljs-comment">// 用于得到 target 对象的 propertyKey 属性的描述对象。在 target 不是对象时，会抛出错误表示参数非法，不会将非对象转换为对象</span>
<span class="hljs-keyword">var</span> exam = {}
<span class="hljs-built_in">Reflect</span>.defineProperty(exam, <span class="hljs-string">'name'</span>, {
  value: <span class="hljs-literal">true</span>,
  enumerable: <span class="hljs-literal">false</span>,
})
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.getOwnPropertyDescriptor(exam, <span class="hljs-string">'name'</span>));
<span class="hljs-comment">// 打印 {value: true, writable: false, enumerable: false, configurable: false}</span>


<span class="hljs-comment">// propertyKey 属性在 target 对象中不存在时，返回 undefined</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.getOwnPropertyDescriptor(exam, <span class="hljs-string">'age'</span>)) <span class="hljs-comment">// 打印 undefined</span>
</code></pre></span><span i="807"><hr>
</span><span i="808"><p><strong>Reflect.isExtensible(target)</strong>    </p>
</span><span i="810"><pre><code><span class="hljs-comment">// 用于判断 target 对象是否可扩展。返回值为 boolean 。如果 target 参数不是对象，会抛出错误</span>
<span class="hljs-keyword">let</span> exam = {};
<span class="hljs-built_in">Reflect</span>.isExtensible(exam); <span class="hljs-comment">// true</span>
</code></pre></span><span i="814"><hr>
</span><span i="815"><p><strong>Reflect.preventExtensions(target)</strong>    </p>
</span><span i="817"><pre><code> <span class="hljs-comment">// 用于让 target 对象变为不可扩展。如果 target 参数不是对象，会抛出错误</span>
<span class="hljs-keyword">let</span> exam = {};
<span class="hljs-built_in">Reflect</span>.preventExtensions(exam);
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.isExtensible(exam)); <span class="hljs-comment">// 打印false</span>
</code></pre></span><span i="822"><hr>
</span><span i="823"><p><strong>Reflect.ownKeys(target)</strong>    </p>
</span><span i="825"><pre><code><span class="hljs-comment">// 用于返回 target 对象的所有属性，等同于 Object.getOwnPropertyNames 与Object.getOwnPropertySymbols 之和</span>
<span class="hljs-keyword">var</span> exam = {
  name: <span class="hljs-number">1</span>,
  [<span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'age'</span>)]: <span class="hljs-number">4</span>
}
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.ownKeys(exam)); <span class="hljs-comment">// 打印 (2) ["name", Symbol(age)]</span>
</code></pre></span><span i="832"><hr>
</span><span i="833"><h3 id="-">组合使用</h3>
</span><span i="834"><p>Reflect 对象的方法与 Proxy 对象的方法是一一对应的。所以 Proxy 对象的方法可以通过调用 Reflect 对象的方法获取默认行为，然后进行额外操作。    </p>
</span><span i="836"><pre><code><span class="hljs-keyword">let</span> exam = {
    name: <span class="hljs-string">"Tom"</span>,
    age: <span class="hljs-number">24</span>
}
<span class="hljs-keyword">let</span> handler = {
    get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, key</span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"getting "</span>+key);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target,key);
    }, <span class="hljs-comment">//注意此处为逗号，而不是分号</span>
    set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, value</span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"setting "</span>+key+<span class="hljs-string">" to "</span>+value)
        <span class="hljs-built_in">Reflect</span>.set(target, key, value);
    }
}
<span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(exam, handler);
<span class="hljs-built_in">console</span>.log(proxy.name); <span class="hljs-comment">// 打印 Tom</span>
proxy.name = <span class="hljs-string">"Jerry"</span>; <span class="hljs-comment">// setting name to Jerry</span>
<span class="hljs-built_in">console</span>.log(proxy.name); <span class="hljs-comment">// 打印 Jerry</span>
</code></pre></span><span i="855"><hr>
</span><span i="856"><h1 id="7-es6-">7. ES6字符串</h1>
</span><span i="857"><h2 id="-">字串的识别</h2>
</span><span i="858"><p>ES6 之前判断字符串是否包含子串，用 indexOf 方法，ES6 新增了子串的识别方法：    </p>
</span><span i="859"><ul>
<li><span i="859">includes()：返回布尔值，判断是否找到参数字符串。    </span></li>
<li><span i="860">startsWith()：返回布尔值，判断参数字符串是否在原字符串的头部。    </span></li>
<li><span i="861">endsWith()：返回布尔值，判断参数字符串是否在原字符串的尾部。    </span></li>
</ul>
</span><span i="864"><p>以上三个方法都可以接受两个参数，需要搜索的字符串，和可选的搜索起始位置索引:</p>
</span><span i="866"><pre><code>let <span class="hljs-keyword">string</span> = <span class="hljs-string">"apple,banana,orange"</span>;
console.<span class="hljs-keyword">log</span>(<span class="hljs-keyword">string</span>.includes(<span class="hljs-string">'banana'</span>)); <span class="hljs-comment">// 打印 true</span>
console.<span class="hljs-keyword">log</span>(<span class="hljs-keyword">string</span>.<span class="hljs-keyword">startsWith</span>(<span class="hljs-string">'apple'</span>)); <span class="hljs-comment">// 打印 true</span>
console.<span class="hljs-keyword">log</span>(<span class="hljs-keyword">string</span>.<span class="hljs-keyword">endsWith</span>(<span class="hljs-string">'apple'</span>)); <span class="hljs-comment">// 打印 false</span>
console.<span class="hljs-keyword">log</span>(<span class="hljs-keyword">string</span>.<span class="hljs-keyword">startsWith</span>(<span class="hljs-string">'banana'</span>, <span class="hljs-number">6</span>)); <span class="hljs-comment">// 打印 true</span>
</code></pre></span><span i="872"><p><strong>注意：</strong>    </p>
</span><span i="873"><ul>
<li><span i="873">这三个方法只返回布尔值，如果需要知道子串的位置，还是得用 indexOf 和 lastIndexOf 。    </span></li>
<li><span i="874">这三个方法如果传入了正则表达式而不是字符串，会抛出错误。而 indexOf 和 lastIndexOf 这两个方法，它们会将正则表达式转换为字符串并搜索它。</span></li>
</ul>
</span><span i="877"><hr>
</span><span i="878"><h2 id="-">字符串重复</h2>
</span><span i="880"><pre><code><span class="hljs-comment">// repeat()：返回新的字符串，表示将字符串重复指定次数返回。    </span>
console.<span class="hljs-built-in">log</span>(<span class="hljs-string">'Hello LSS '</span>.<span class="hljs-keyword">repeat</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 打印 Hello LSS Hello LSS </span>

<span class="hljs-comment">// 如果参数是小数，向下取整</span>
console.<span class="hljs-built-in">log</span>(<span class="hljs-string">'Hello LSS '</span>.<span class="hljs-keyword">repeat</span>(<span class="hljs-number">3.2</span>)); <span class="hljs-comment">// 打印 Hello LSS Hello LSS Hello LSS </span>

<span class="hljs-comment">//如果参数是 0 至 -1 之间的小数，会进行取整运算，0 至 -1 之间的小数取整得到 -0 ，等同于 repeat 零次</span>
console.<span class="hljs-built-in">log</span>(<span class="hljs-string">'Hello LSS '</span>.<span class="hljs-keyword">repeat</span>(<span class="hljs-number">-0.5</span>)); <span class="hljs-comment">// 打印 ""</span>

<span class="hljs-comment">// 如果参数是 NaN，等同于 repeat 零次</span>
console.<span class="hljs-built-in">log</span>(<span class="hljs-string">'Hello LSS '</span>.<span class="hljs-keyword">repeat</span>(NaN)); <span class="hljs-comment">// 打印 ""</span>

<span class="hljs-comment">// 如果参数是负数或者 Infinity ，会报错:</span>
console.<span class="hljs-built-in">log</span>(<span class="hljs-string">'Hello LSS '</span>.<span class="hljs-keyword">repeat</span>(<span class="hljs-number">-1</span>));
console.<span class="hljs-built-in">log</span>(<span class="hljs-string">'Hello LSS '</span>.<span class="hljs-keyword">repeat</span>(Infinity)); 
<span class="hljs-comment">// 报错 Uncaught RangeError: Invalid count value at String.repeat</span>

<span class="hljs-comment">// 如果传入的参数是字符串，则会先将字符串转化为数字</span>
console.<span class="hljs-built-in">log</span>(<span class="hljs-string">'Hello LSS '</span>.<span class="hljs-keyword">repeat</span>(<span class="hljs-string">'hh'</span>)); <span class="hljs-comment">// 打印 ""</span>
console.<span class="hljs-built-in">log</span>(<span class="hljs-string">'Hello LSS '</span>.<span class="hljs-keyword">repeat</span>(<span class="hljs-string">'2'</span>)); <span class="hljs-comment">// 打印 Hello LSS Hello LSS</span>
</code></pre></span><span i="901"><hr>
</span><span i="902"><h2 id="-">字符串补全</h2>
</span><span i="903"><p>以下两种方法：</p>
</span><span i="904"><ul>
<li><span i="904">padStart：返回新的字符串，表示用参数字符串从头部补全原字符串。</span></li>
<li><span i="905">padEnd：返回新的字符串，表示用参数字符串从头部补全原字符串。</span></li>
</ul>
</span><span i="909"><pre><code><span class="hljs-comment">//以上两个方法接受两个参数，第一个参数是指定生成的字符串的最小长度，第二个参数是用来补全的字符串。如果没有指定第二个参数，默认用空格填充。</span>
console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">"h"</span>.padStart(<span class="hljs-number">5</span>,<span class="hljs-string">"o"</span>));  <span class="hljs-comment">// "ooooh"</span>
console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">"h"</span>.padEnd(<span class="hljs-number">5</span>,<span class="hljs-string">"o"</span>));    <span class="hljs-comment">// "hoooo"</span>
console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">"h"</span>.padStart(<span class="hljs-number">5</span>));      <span class="hljs-comment">// "    h"</span>

<span class="hljs-comment">// 如果指定的长度小于或者等于原字符串的长度，则返回原字符串:</span>
console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">"hello"</span>.padStart(<span class="hljs-number">5</span>,<span class="hljs-string">"A"</span>));  <span class="hljs-comment">// "hello"</span>
console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">"hello"</span>.padStart(<span class="hljs-number">4</span>,<span class="hljs-string">"A"</span>));  <span class="hljs-comment">// "hello"</span>

<span class="hljs-comment">// 如果原字符串加上补全字符串长度大于指定长度，则截去超出位数的补全字符串:</span>
console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">"hello"</span>.padEnd(<span class="hljs-number">10</span>,<span class="hljs-string">",world!"</span>));  <span class="hljs-comment">// "hello,worl"</span>

<span class="hljs-comment">// 常用于补全位数：</span>
console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">"123"</span>.padStart(<span class="hljs-number">10</span>,<span class="hljs-string">"0"</span>));  <span class="hljs-comment">// "0000000123"</span>
</code></pre></span><span i="924"><hr>
</span><span i="925"><h2 id="-">模板字符串</h2>
</span><span i="926"><p>模板字符串相当于加强版的字符串，用反引号 ` ,除了作为普通字符串，还可以用来定义多行字符串，还可以在字符串中加入变量和表达式。    </p>
</span><span i="928"><p><strong>基本用法：</strong>    </p>
</span><span i="930"><pre><code><span class="hljs-comment">// 普通字符串</span>
<span class="hljs-keyword">let</span> <span class="hljs-built_in">string</span> = <span class="hljs-string">`Hello, \n LSS`</span>;
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">string</span>); 
<span class="hljs-comment">// 打印 Hello,</span>
<span class="hljs-comment">//       LSS</span>

<span class="hljs-comment">// 多行字符串:</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hello
Lss`</span>);
<span class="hljs-comment">// 打印 Hello</span>
<span class="hljs-comment">//      LSS</span>

<span class="hljs-comment">// 字符串插入变量和表达式</span>
<span class="hljs-comment">//变量名写在 ${} 中，${} 中可以放入 JavaScript 表达式</span>
<span class="hljs-keyword">let</span> name = <span class="hljs-string">"CKX"</span>;
<span class="hljs-keyword">let</span> L_name = <span class="hljs-string">"LSS"</span>;
<span class="hljs-keyword">let</span> str = <span class="hljs-string">`Hello, my name is <span class="hljs-subst">${name}</span> and I like <span class="hljs-subst">${L_name}</span>`</span>;
<span class="hljs-built_in">console</span>.log(str);
<span class="hljs-comment">// 打印 Hello, my name is CKX and I like LSS</span>

<span class="hljs-comment">// 字符串中调用函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-keyword">return</span> <span class="hljs-string">'I like LSS'</span>;}

<span class="hljs-keyword">let</span> str1 = <span class="hljs-string">`Hello, my name is CKX and <span class="hljs-subst">${f()}</span>`</span>;
<span class="hljs-built_in">console</span>.log(str1);
<span class="hljs-comment">// 打印 Hello, my name is CKX and I like LSS</span>
</code></pre></span><span i="957"><p><strong>注意要点:</strong><br>模板字符串中的换行和空格都是会被保留的    </p>
</span><span i="960"><pre><code>innerHtml = `<span class="hljs-params">&lt;ul&gt;</span>
  <span class="hljs-params">&lt;li&gt;</span>menu<span class="hljs-params">&lt;/li&gt;</span>
  <span class="hljs-params">&lt;li&gt;</span>mine<span class="hljs-params">&lt;/li&gt;</span>
<span class="hljs-params">&lt;/ul&gt;</span>
`;
console.log(innerHtml);
<span class="hljs-comment">// 打印 </span>
<span class="hljs-params">&lt;ul&gt;</span>
 <span class="hljs-params">&lt;li&gt;</span>menu<span class="hljs-params">&lt;/li&gt;</span>
 <span class="hljs-params">&lt;li&gt;</span>mine<span class="hljs-params">&lt;/li&gt;</span>
<span class="hljs-params">&lt;/ul&gt;</span>
</code></pre></span><span i="972"><hr>
</span><span i="973"><h2 id="-">标签模板</h2>
</span><span i="974"><p>标签模板，是一个函数的调用，其中调用的参数是模板字符串。    </p>
</span><span i="976"><pre><code>alert<span class="hljs-string">`Hello world!`</span>;
<span class="hljs-regexp">//</span> 等价于
alert(<span class="hljs-string">'Hello world!'</span>);
</code></pre></span><span i="980"><p>当模板字符串中带有变量，会将模板字符串参数处理成多个参数。    </p>
</span><span i="982"><pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(stringArr,<span class="hljs-rest_arg">...values</span>)</span></span>{
 let result = <span class="hljs-string">""</span>;
 <span class="hljs-keyword">for</span>(let i=<span class="hljs-number">0</span>;i&lt;stringArr.length;i++){
  result += stringArr[i];
  <span class="hljs-keyword">if</span>(values[i]){
   result += values[i];
        }
    }
 <span class="hljs-keyword">return</span> result;
}
let name = <span class="hljs-string">'Mike'</span>;
let age = <span class="hljs-number">27</span>;
console.log(f`My Name <span class="hljs-keyword">is</span> ${name},I am ${age+<span class="hljs-number">1</span>} years old next year.`);
<span class="hljs-comment">// 打印 My Name is Mike,I am 28 years old next year.</span>

<span class="hljs-comment">/*
f`My Name is ${name},I am ${age+1} years old next year.`;
等价于
f(['My Name is',',I am ',' years old next year.'],'Mike',28);
*/</span>
</code></pre></span><span i="1003"><hr>
</span><span i="1004"><h1 id="8-es6-">8. ES6 数值</h1>
</span><span i="1005"><h2 id="-">数值的表示</h2>
</span><span i="1006"><p>二进制表示法新写法: 前缀 0b 或 0B</p>
</span><span i="1008"><pre><code>console.<span class="hljs-built_in">log</span>(<span class="hljs-number">0b11</span> === <span class="hljs-number">3</span>); // <span class="hljs-literal">true</span>
console.<span class="hljs-built_in">log</span>(<span class="hljs-number">0B11</span> === <span class="hljs-number">3</span>); // <span class="hljs-literal">true</span>
</code></pre></span><span i="1011"><p>八进制表示法新写法: 前缀 0o 或 0O </p>
</span><span i="1013"><pre><code>console<span class="hljs-selector-class">.log</span>(<span class="hljs-number">0</span>o11 === <span class="hljs-number">9</span>); <span class="hljs-comment">// true</span>
console<span class="hljs-selector-class">.log</span>(<span class="hljs-number">0</span>O11 === <span class="hljs-number">9</span>); <span class="hljs-comment">// true</span>
</code></pre></span><span i="1015"><hr>
</span><span i="1016"><h3 id="-">常量</h3>
</span><span i="1017"><p><br>
<strong>Number.EPSILON</strong>    </p>
</span><span i="1020"><pre><code><span class="hljs-comment">// Number.EPSILON 属性表示 1 与大于 1 的最小浮点数之间的差</span>
<span class="hljs-comment">// 它的值接近于 2.2204460492503130808472633361816E-16，或者 2-52</span>

<span class="hljs-comment">//测试数值是否在误差范围内:</span>
<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> === <span class="hljs-number">0.3</span>; <span class="hljs-comment">// false</span>
<span class="hljs-comment">// 在误差范围内即视为相等</span>
equal = (Math.abs(<span class="hljs-number">0.1</span> - <span class="hljs-number">0.3</span> + <span class="hljs-number">0.2</span>) &lt; Number.EPSILON); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 属性特性</span>
writable：false
enumerable：false
configurable：false
</code></pre></span><span i="1032"><hr>
</span><span i="1034"><p><strong>最大/最小安全整数</strong><br>安全整数表示在 JavaScript 中能够精确表示的整数，安全整数的范围在 2 的 -53 次方到 2 的 53 次方之间（不包括两个端点），超过这个范围的整数无法精确表示。</p>
</span><span i="1037"><pre><code><span class="hljs-comment">// 最大安全整数,安全整数范围的上限，即 2 的 53 次方减 1 </span>
<span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER + <span class="hljs-number">1</span> ===     <span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER + <span class="hljs-number">2</span>; <span class="hljs-comment">// true</span>
<span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER === <span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER + <span class="hljs-number">1</span>;     <span class="hljs-comment">// false</span>
<span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER - <span class="hljs-number">1</span> === <span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER - <span class="hljs-number">2</span>; <span class="hljs-comment">// false</span>

<span class="hljs-comment">// 最小安全整数,安全整数范围的下限，即 2 的 -53 次方减 1 </span>
<span class="hljs-built_in">Number</span>.MIN_SAFE_INTEGER + <span class="hljs-number">1</span> === <span class="hljs-built_in">Number</span>.MIN_SAFE_INTEGER + <span class="hljs-number">2</span>; <span class="hljs-comment">// false</span>
<span class="hljs-built_in">Number</span>.MIN_SAFE_INTEGER === <span class="hljs-built_in">Number</span>.MIN_SAFE_INTEGER - <span class="hljs-number">1</span>;     <span class="hljs-comment">// false</span>
<span class="hljs-built_in">Number</span>.MIN_SAFE_INTEGER - <span class="hljs-number">1</span> === <span class="hljs-built_in">Number</span>.MIN_SAFE_INTEGER - <span class="hljs-number">2</span>; <span class="hljs-comment">//false</span>

<span class="hljs-comment">// 属性特性</span>
writable：<span class="hljs-literal">false</span>
enumerable：<span class="hljs-literal">false</span>
configurable：<span class="hljs-literal">false</span>
</code></pre></span><span i="1051"><hr>
</span><span i="1053"><h3 id="-">方法</h3>
</span><span i="1055"><p><strong>Number.isFinite()</strong>    </p>
</span><span i="1057"><pre><code><span class="hljs-comment">//用于检查一个数是否为有限的(finite)， 即不是Infinity</span>
<span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">Number</span>.isFinite(<span class="hljs-number">1</span>));   <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">Number</span>.isFinite(<span class="hljs-number">0.1</span>)); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// NaN 不是有限的</span>
<span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">Number</span>.isFinite(<span class="hljs-literal">NaN</span>)); <span class="hljs-comment">// false</span>

<span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">Number</span>.isFinite(<span class="hljs-literal">Infinity</span>));  <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">Number</span>.isFinite(-<span class="hljs-literal">Infinity</span>)); <span class="hljs-comment">// false</span>

<span class="hljs-comment">// Number.isFinate 没有隐式的 Number() 类型转换，所有非数值都返回 false</span>
<span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">Number</span>.isFinite(<span class="hljs-string">'foo'</span>)); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">Number</span>.isFinite(<span class="hljs-string">'15'</span>));  <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">Number</span>.isFinite(<span class="hljs-literal">true</span>));  <span class="hljs-comment">// false</span>
</code></pre></span><span i="1071"><hr>
</span><span i="1073"><p><strong>Number.isNaN()</strong>    </p>
</span><span i="1075"><pre><code><span class="hljs-comment">//用于检查一个值是否为 NaN 。</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isNaN(<span class="hljs-literal">NaN</span>));      <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isNaN(<span class="hljs-string">'true'</span>/<span class="hljs-number">0</span>)); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 在全局的 isNaN() 中，以下皆返回 true，因为在判断前会将非数值向数值转换</span>
<span class="hljs-comment">// 而 Number.isNaN() 不存在隐式的 Number() 类型转换，非 NaN 全部返回 false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isNaN(<span class="hljs-string">"NaN"</span>));      <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isNaN(<span class="hljs-literal">undefined</span>));  <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isNaN({}));         <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isNaN(<span class="hljs-string">"true"</span>));     <span class="hljs-comment">// false</span>
</code></pre></span><span i="1085"><hr>
</span><span i="1087"><p><strong>Number.parseInt()</strong>    </p>
</span><span i="1089"><pre><code><span class="hljs-comment">// 用于将给定字符串转化为指定进制的整数</span>
<span class="hljs-comment">// 不指定进制时默认为 10 进制</span>
Number.<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'12.34'</span>); <span class="hljs-comment">// 12</span>
Number.<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">12.34</span>);   <span class="hljs-comment">// 12</span>

<span class="hljs-comment">//// 指定进制</span>
Number.<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'0011'</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// 3</span>

<span class="hljs-comment">// 与全局的 parseInt() 函数是同一个函数</span>
Number.<span class="hljs-built_in">parseInt</span> === <span class="hljs-built_in">parseInt</span>; <span class="hljs-comment">// true</span>
</code></pre></span><span i="1099"><hr>
</span><span i="1101"><p>**Number.parseFloat</p>
</span><span i="1103"><pre><code><span class="hljs-comment">// 用于把一个字符串解析成浮点数</span>
Number.<span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">'123.45'</span>)    <span class="hljs-comment">// 123.45</span>
Number.<span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">'123.45abc'</span>) <span class="hljs-comment">// 123.45</span>

<span class="hljs-comment">// 无法被解析成浮点数，则返回 NaN</span>
Number.<span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">'abc'</span>) <span class="hljs-comment">// NaN</span>

<span class="hljs-comment">// 与全局的 parseFloat() 方法是同一个方法</span>
Number.<span class="hljs-built_in">parseFloat</span> === <span class="hljs-built_in">parseFloat</span> <span class="hljs-comment">// true</span>
</code></pre></span><span i="1112"><hr>
</span><span i="1114"><p><strong>Number.isInteger()</strong>    </p>
</span><span i="1116"><pre><code><span class="hljs-comment">// 用于判断给定的参数是否为整数。</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isInteger(<span class="hljs-number">0</span>)); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// JavaScript 内部，整数和浮点数采用的是同样的储存方法,因此 1 与 1.0 被视为相同的值</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isInteger(<span class="hljs-number">1</span>));   <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isInteger(<span class="hljs-number">1.0</span>)); <span class="hljs-comment">// true </span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isInteger(<span class="hljs-number">1.1</span>));     <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isInteger(<span class="hljs-built_in">Math</span>.PI)); <span class="hljs-comment">// false</span>

<span class="hljs-comment">// NaN 和正负 Infinity 不是整数</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isInteger(<span class="hljs-literal">NaN</span>));       <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isInteger(<span class="hljs-literal">Infinity</span>));  <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isInteger(-<span class="hljs-literal">Infinity</span>)); <span class="hljs-comment">// false</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isInteger(<span class="hljs-string">"10"</span>));  <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isInteger(<span class="hljs-literal">true</span>));  <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isInteger(<span class="hljs-literal">false</span>)); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isInteger([<span class="hljs-number">1</span>]));   <span class="hljs-comment">// false</span>

<span class="hljs-comment">// 数值的精度超过 53 个二进制位时，由于第 54 位及后面的位被丢弃，会产生误判</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isInteger(<span class="hljs-number">1.0000000000000001</span>)) <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 一个数值的绝对值小于 Number.MIN_VALUE（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0，也会产生误判</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isInteger(<span class="hljs-number">5E-324</span>)); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isInteger(<span class="hljs-number">5E-325</span>)); <span class="hljs-comment">// true</span>
</code></pre></span><span i="1141"><hr>
</span><span i="1143"><p><strong>Number.isSafeInteger()</strong>    </p>
</span><span i="1145"><pre><code><span class="hljs-comment">// 用于判断数值是否在安全范围内</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isSafeInteger(<span class="hljs-built_in">Number</span>.MIN_SAFE_INTEGER - <span class="hljs-number">1</span>)); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isSafeInteger(<span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER + <span class="hljs-number">1</span>)); <span class="hljs-comment">// false</span>
</code></pre></span><span i="1148"><hr>
</span><span i="1150"><h2 id="math-">Math对象的扩展</h2>
</span><span i="1151"><p>ES6 在 Math 对象上新增了 17 个数学相关的静态方法，这些方法只能在 Math 中调用。</p>
</span><span i="1153"><p><strong>Math.cbrt()</strong>    </p>
</span><span i="1155"><pre><code><span class="hljs-comment">// 用于计算一个数的立方根</span>
console<span class="hljs-selector-class">.log</span>(Math.cbrt(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 1</span>
console<span class="hljs-selector-class">.log</span>(Math.cbrt(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 0</span>
console<span class="hljs-selector-class">.log</span>(Math.cbrt(-<span class="hljs-number">1</span>)); <span class="hljs-comment">// -1</span>
console<span class="hljs-selector-class">.log</span>(Math.cbrt(<span class="hljs-number">8</span>)); <span class="hljs-comment">// 2</span>

<span class="hljs-comment">// 会对非数值进行转换</span>
Math<span class="hljs-selector-class">.cbrt</span>(<span class="hljs-string">'1'</span>); <span class="hljs-comment">// 1</span>

<span class="hljs-comment">// 非数值且无法转换为数值时返回 NaN</span>
Math<span class="hljs-selector-class">.cbrt</span>(<span class="hljs-string">'hhh'</span>); <span class="hljs-comment">// NaN</span>
</code></pre></span><span i="1166"><hr>
</span><span i="1168"><p><strong>Math.imul()</strong>    </p>
</span><span i="1170"><pre><code><span class="hljs-comment">// 两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数</span>
<span class="hljs-comment">// 大多数情况下，结果与 a * b 相同 </span>
Math<span class="hljs-selector-class">.imul</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);   <span class="hljs-comment">// 2</span>
Math<span class="hljs-selector-class">.imul</span>(-<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);   <span class="hljs-comment">// -4</span>

<span class="hljs-comment">// 用于正确返回大数乘法结果中的低位数值</span>
Math<span class="hljs-selector-class">.imul</span>(<span class="hljs-number">0</span>x7fffffff, <span class="hljs-number">0</span>x7fffffff); <span class="hljs-comment">// 1</span>
</code></pre></span><span i="1177"><hr>
</span><span i="1179"><p><strong>Math.hypot()</strong>    </p>
</span><span i="1181"><pre><code><span class="hljs-comment">// 用于计算所有参数平方和的平方根</span>
Math<span class="hljs-selector-class">.hypot</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 5</span>

<span class="hljs-comment">// 非数值会先被转换为数值后进行计算</span>
Math<span class="hljs-selector-class">.hypot</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'3'</span>); <span class="hljs-comment">// 3.741657386773941</span>
Math<span class="hljs-selector-class">.hypot</span>(true);      <span class="hljs-comment">// 1</span>
Math<span class="hljs-selector-class">.hypot</span>(false);     <span class="hljs-comment">// 0</span>

<span class="hljs-comment">// 空值会被转换为 0</span>
Math<span class="hljs-selector-class">.hypot</span>();   <span class="hljs-comment">// 0</span>
Math<span class="hljs-selector-class">.hypot</span>([]); <span class="hljs-comment">// 0</span>
<span class="hljs-comment">// 注意，当括号内为大括号({})时，无法转换，返回NaN</span>

<span class="hljs-comment">// 参数为 Infinity 或 -Infinity 返回 Infinity</span>
Math<span class="hljs-selector-class">.hypot</span>(Infinity); <span class="hljs-comment">// Infinity</span>
Math<span class="hljs-selector-class">.hypot</span>(-Infinity); <span class="hljs-comment">// Infinity</span>

<span class="hljs-comment">// 参数中存在无法转换为数值的参数时返回 NaN</span>
Math<span class="hljs-selector-class">.hypot</span>(NaN);         <span class="hljs-comment">// NaN</span>
Math<span class="hljs-selector-class">.hypot</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-string">'foo'</span>); <span class="hljs-comment">// NaN</span>
<span class="hljs-selector-tag">Math</span><span class="hljs-selector-class">.hypot</span>({});          <span class="hljs-comment">// NaN ， 无法转换</span>
</code></pre></span><span i="1202"><hr>
</span><span i="1204"><p><strong>Math.clz32()</strong>    </p>
</span><span i="1206"><pre><code><span class="hljs-comment">// 用于返回数字的32位无符号整数形式的前导 0 的个数</span>
Math<span class="hljs-selector-class">.clz32</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 32</span>
Math<span class="hljs-selector-class">.clz32</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 31</span>
Math<span class="hljs-selector-class">.clz32</span>(<span class="hljs-number">0</span>b00100000000100000000000000000000); <span class="hljs-comment">// 2</span>

<span class="hljs-comment">// 当参数为小数时，只考虑整数部分</span>
Math<span class="hljs-selector-class">.clz32</span>(<span class="hljs-number">0.5</span>); <span class="hljs-comment">// 32</span>

<span class="hljs-comment">// 对于空值或非数值，会转化为数值再进行计算</span>
Math<span class="hljs-selector-class">.clz32</span>(<span class="hljs-string">'1'</span>);       <span class="hljs-comment">// 31</span>
Math<span class="hljs-selector-class">.clz32</span>();          <span class="hljs-comment">// 32</span>
Math<span class="hljs-selector-class">.clz32</span>([]);        <span class="hljs-comment">// 32</span>
<span class="hljs-selector-tag">Math</span><span class="hljs-selector-class">.clz32</span>({});        <span class="hljs-comment">// 32</span>
<span class="hljs-selector-tag">Math</span><span class="hljs-selector-class">.clz32</span>(NaN);       <span class="hljs-comment">// 32</span>
<span class="hljs-selector-tag">Math</span><span class="hljs-selector-class">.clz32</span>(Infinity);  <span class="hljs-comment">// 32</span>
<span class="hljs-selector-tag">Math</span><span class="hljs-selector-class">.clz32</span>(-Infinity); <span class="hljs-comment">// 32</span>
<span class="hljs-selector-tag">Math</span><span class="hljs-selector-class">.clz32</span>(undefined); <span class="hljs-comment">// 32</span>
<span class="hljs-selector-tag">Math</span><span class="hljs-selector-class">.clz32</span>(<span class="hljs-string">'hhh'</span>);     <span class="hljs-comment">// 32</span>
</code></pre></span><span i="1224"><hr>
</span><span i="1226"><p><strong>Math.trunc()</strong>    </p>
</span><span i="1228"><pre><code><span class="hljs-comment">// 用于返回数字的整数部分</span>
Math<span class="hljs-selector-class">.trunc</span>(<span class="hljs-number">12.3</span>); <span class="hljs-comment">// 12</span>
Math<span class="hljs-selector-class">.trunc</span>(<span class="hljs-number">12</span>);   <span class="hljs-comment">// 12</span>
Math<span class="hljs-selector-class">.trunc</span>(-<span class="hljs-number">12</span>。<span class="hljs-number">5</span>);   <span class="hljs-comment">// -12</span>

<span class="hljs-comment">// 整数部分为 0 时也会判断符号</span>
Math<span class="hljs-selector-class">.trunc</span>(-<span class="hljs-number">0.5</span>); <span class="hljs-comment">// -0</span>
Math<span class="hljs-selector-class">.trunc</span>(<span class="hljs-number">0.5</span>);  <span class="hljs-comment">// 0</span>

<span class="hljs-comment">// Math.trunc 会将非数值转为数值再进行处理</span>
Math<span class="hljs-selector-class">.trunc</span>(<span class="hljs-string">"12.3"</span>); <span class="hljs-comment">// 12</span>

<span class="hljs-comment">// 空值或无法转化为数值时时返回 NaN</span>
Math<span class="hljs-selector-class">.trunc</span>();           <span class="hljs-comment">// NaN</span>
Math<span class="hljs-selector-class">.trunc</span>(NaN);        <span class="hljs-comment">// NaN</span>
Math<span class="hljs-selector-class">.trunc</span>(<span class="hljs-string">"hhh"</span>);      <span class="hljs-comment">// NaN</span>
Math<span class="hljs-selector-class">.trunc</span>(<span class="hljs-string">"123.2hhh"</span>); <span class="hljs-comment">// NaN</span>
</code></pre></span><span i="1245"><hr>
</span><span i="1247"><p><strong>Math.fround()</strong>    </p>
</span><span i="1249"><pre><code><span class="hljs-comment">// 用于获取数字的32位单精度浮点数形式    </span>
<span class="hljs-comment">// 对于 负的 2 的 24 次方至 2 的 24 次方之间的整数（不含两个端点），返回结果与参数本身一致</span>
Math<span class="hljs-selector-class">.fround</span>(-(<span class="hljs-number">2</span>**<span class="hljs-number">24</span>)+<span class="hljs-number">1</span>);  <span class="hljs-comment">// -16777215</span>
Math<span class="hljs-selector-class">.fround</span>(<span class="hljs-number">2</span> ** <span class="hljs-number">24</span> - <span class="hljs-number">1</span>); <span class="hljs-comment">// 16777215</span>

<span class="hljs-comment">// 用于将 64 位双精度浮点数转为 32 位单精度浮点数</span>
Math<span class="hljs-selector-class">.fround</span>(<span class="hljs-number">1.234</span>) <span class="hljs-comment">// 1.125</span>

<span class="hljs-comment">// 当小数的精度超过 24 个二进制位，会丢失精度</span>
<span class="hljs-selector-tag">Math</span><span class="hljs-selector-class">.fround</span>(<span class="hljs-number">0.3</span>); <span class="hljs-comment">// 0.30000001192092896</span>

<span class="hljs-comment">// 参数为 NaN 或 Infinity 时返回本身</span>
Math<span class="hljs-selector-class">.fround</span>(NaN)      <span class="hljs-comment">// NaN</span>
<span class="hljs-selector-tag">Math</span><span class="hljs-selector-class">.fround</span>(Infinity) <span class="hljs-comment">// Infinity</span>

<span class="hljs-comment">// 参数为其他非数值类型时会将参数进行转换 </span>
<span class="hljs-selector-tag">Math</span><span class="hljs-selector-class">.fround</span>(<span class="hljs-string">'5'</span>);  <span class="hljs-comment">// 5</span>
Math<span class="hljs-selector-class">.fround</span>(true); <span class="hljs-comment">// 1</span>
Math<span class="hljs-selector-class">.fround</span>(null); <span class="hljs-comment">// 0</span>
Math<span class="hljs-selector-class">.fround</span>([]);   <span class="hljs-comment">// 0</span>
<span class="hljs-selector-tag">Math</span><span class="hljs-selector-class">.fround</span>({});   <span class="hljs-comment">// NaN</span>
</code></pre></span><span i="1270"><hr>
</span><span i="1272"><p><strong>Math.sign()</strong>    </p>
</span><span i="1274"><pre><code><span class="hljs-comment">// 判断数字的符号(正、负、0)</span>
Math<span class="hljs-selector-class">.sign</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 1</span>
Math<span class="hljs-selector-class">.sign</span>(-<span class="hljs-number">1</span>); <span class="hljs-comment">// -1</span>
Math<span class="hljs-selector-class">.sign</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 1</span>
Math<span class="hljs-selector-class">.sign</span>(-<span class="hljs-number">5</span>); <span class="hljs-comment">// -1</span>

<span class="hljs-comment">// 参数为 0 时，不同符号的返回不同</span>
Math<span class="hljs-selector-class">.sign</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 0</span>
Math<span class="hljs-selector-class">.sign</span>(-<span class="hljs-number">0</span>); <span class="hljs-comment">// -0</span>

<span class="hljs-comment">// 判断前会对非数值进行转换</span>
Math<span class="hljs-selector-class">.sign</span>(<span class="hljs-string">'1'</span>);  <span class="hljs-comment">// 1</span>
Math<span class="hljs-selector-class">.sign</span>(<span class="hljs-string">'-1'</span>); <span class="hljs-comment">// -1  </span>

<span class="hljs-comment">// 参数为非数值（无法转换为数值）时返回 NaN</span>
Math<span class="hljs-selector-class">.sign</span>(NaN);   <span class="hljs-comment">// NaN </span>
Math<span class="hljs-selector-class">.sign</span>(<span class="hljs-string">'hhh'</span>); <span class="hljs-comment">// NaN</span>
</code></pre></span><span i="1291"><hr>
</span><span i="1293"><p><strong>Math.expm1(x)</strong>    </p>
</span><span i="1295"><pre><code><span class="hljs-comment">// 用于计算 e 的 x 次方减 1 的结果(即 Math.exp(x)-1)</span>
Math<span class="hljs-selector-class">.expm1</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 1.718281828459045</span>
Math<span class="hljs-selector-class">.expm1</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 0</span>
Math<span class="hljs-selector-class">.expm1</span>(-<span class="hljs-number">1</span>); <span class="hljs-comment">// -0.6321205588285577</span>

<span class="hljs-comment">// 会对非数值进行转换</span>
Math<span class="hljs-selector-class">.expm1</span>(<span class="hljs-string">'0'</span>); <span class="hljs-comment">//0</span>

<span class="hljs-comment">// 参数不为数值且无法转换为数值时返回 NaN</span>
Math<span class="hljs-selector-class">.expm1</span>(NaN); <span class="hljs-comment">// NaN</span>
</code></pre></span><span i="1305"><hr>
</span><span i="1307"><p><strong>Math.log1p(x)</strong>    </p>
</span><span i="1309"><pre><code><span class="hljs-comment">//  用于计算 1+x 的自然对数(即 Math.log(1+x))</span>
Math.lo<span class="hljs-name">g1</span>p<span class="hljs-comment">(1)</span>;  <span class="hljs-comment">// 0.6931471805599453</span>
Math.lo<span class="hljs-name">g1</span>p<span class="hljs-comment">(0)</span>;  <span class="hljs-comment">// 0</span>
Math.lo<span class="hljs-name">g1</span>p<span class="hljs-comment">(-1)</span>; <span class="hljs-comment">// -Infinity</span>

<span class="hljs-comment">// 参数小于 -1 时返回 NaN</span>
Math.lo<span class="hljs-name">g1</span>p<span class="hljs-comment">(-2)</span>; <span class="hljs-comment">// NaN</span>
</code></pre></span><span i="1316"><hr>
</span><span i="1318"><p><strong>Math.log10(x)</strong>    </p>
</span><span i="1320"><pre><code><span class="hljs-comment">// 用于计算以 10 为底的 x 的对数</span>
Math<span class="hljs-selector-class">.log10</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">// 0</span>
Math<span class="hljs-selector-class">.log10</span>(<span class="hljs-number">10</span>);   <span class="hljs-comment">// 1</span>
Math<span class="hljs-selector-class">.log10</span>(<span class="hljs-number">0.1</span>);   <span class="hljs-comment">// -1</span>

<span class="hljs-comment">// 计算前对非数值进行转换</span>
Math<span class="hljs-selector-class">.log10</span>(<span class="hljs-string">'1'</span>); <span class="hljs-comment">// 0</span>

<span class="hljs-comment">// 参数为0时返回 -Infinity</span>
Math<span class="hljs-selector-class">.log10</span>(<span class="hljs-number">0</span>);   <span class="hljs-comment">// -Infinity</span>

<span class="hljs-comment">// 参数小于0或参数不为数值（且无法转换为数值）时返回 NaN</span>
Math<span class="hljs-selector-class">.log10</span>(-<span class="hljs-number">1</span>);  <span class="hljs-comment">// NaN</span>
</code></pre></span><span i="1333"><hr>
</span><span i="1335"><p><strong>Math.log2()</strong>    </p>
</span><span i="1337"><pre><code><span class="hljs-comment">// 用于计算以 2 为底的 x 的对数</span>
Math<span class="hljs-selector-class">.log2</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">// 0</span>

<span class="hljs-comment">// 计算前对非数值进行转换</span>
Math<span class="hljs-selector-class">.log2</span>(<span class="hljs-string">'1'</span>); <span class="hljs-comment">// 0</span>

<span class="hljs-comment">// 参数为0时返回 -Infinity</span>
Math<span class="hljs-selector-class">.log2</span>(<span class="hljs-number">0</span>);   <span class="hljs-comment">// -Infinity</span>

<span class="hljs-comment">// 参数小于0或参数不为数值（且无法转换为数值）时返回 NaN</span>
Math<span class="hljs-selector-class">.log2</span>(-<span class="hljs-number">1</span>);  <span class="hljs-comment">// NaN</span>
</code></pre></span><span i="1348"><hr>
</span><span i="1350"><p><strong>双曲线函数方法</strong>    </p>
</span><span i="1352"><pre><code>Math<span class="hljs-selector-class">.sinh</span>(x); <span class="hljs-comment">// 用于计算双曲正弦。</span>
Math<span class="hljs-selector-class">.cosh</span>(x); <span class="hljs-comment">// 用于计算双曲余弦。</span>
Math<span class="hljs-selector-class">.tanh</span>(x); <span class="hljs-comment">// 用于计算双曲正切。</span>
Math<span class="hljs-selector-class">.asinh</span>(x); <span class="hljs-comment">// 用于计算反双曲正弦。</span>
Math<span class="hljs-selector-class">.acosh</span>(x); <span class="hljs-comment">// 用于计算反双曲余弦。</span>
Math<span class="hljs-selector-class">.atanh</span>(x); <span class="hljs-comment">// 用于计算反双曲正切。</span>
</code></pre></span><span i="1358"><hr>
</span><span i="1360"><p><strong>指数运算符</strong>    </p>
</span><span i="1362"><pre><code><span class="hljs-comment">// a ** b, 即 a 的 b 次幂</span>
<span class="hljs-number">1</span> ** <span class="hljs-number">2</span>; <span class="hljs-comment">// 1</span>
<span class="hljs-number">3</span> ** <span class="hljs-number">2</span>; <span class="hljs-comment">// 9</span>

<span class="hljs-comment">// 右结合，从右至左计算</span>
<span class="hljs-number">2</span> ** <span class="hljs-number">2</span> ** <span class="hljs-number">3</span>; <span class="hljs-comment">// 256</span>
<span class="hljs-number">3</span> ** <span class="hljs-number">2</span> ** <span class="hljs-number">2</span>; <span class="hljs-comment">// 81</span>
</code></pre></span><span i="1369"><hr>
</span><span i="1371"><h1 id="9-es6-">9. ES6 对象</h1>
</span></body>
</html>